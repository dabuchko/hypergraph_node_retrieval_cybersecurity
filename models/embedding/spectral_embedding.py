import torch
from scipy.sparse.linalg import lobpcg
from scipy.sparse import coo_matrix
import numpy as np

def _construct_unnormalized_laplacian(edge_index: torch.Tensor, edge_weight: torch.Tensor = None):
    """
    Generates unnormalized Laplacian matrix L and degree vector D based on the
    provided edge indices and their corresponding weights (weight 1 is assumed for
    all edges if not provided). The method returns a pair (L, D). The input graph
    is assumed to be undirected.
    
    :param edge_index: Tensor of size (2, M) where M is a number of edges. Graph is
    assumed to be undirected, and it assumed to contain edges in both directions
    in 'edge_weight', except for self-loops.
    :type edge_index: torch.Tensor
    :param edge_weight: Vector of size M, defines a non-negative weight of the
    corresponding edge from 'edge_index'
    :type edge_weight: torch.Tensor
    """
    # generate edge weights if not provided
    if edge_weight==None:
        edge_weight = torch.ones((edge_index.shape[1],))
    else:
        edge_weight = edge_weight.clone()
    edge_index = edge_index.clone()
    
    num_nodes = edge_index.max().item() + 1
    # construct degree vector D, which is utilized in a form of diagonal matrix
    # in the original algorithm
    D = torch.zeros((num_nodes,))
    same = edge_index[0]==edge_index[1]
    # zero self edges, before computing D
    edge_weight[same] = 0
    D.scatter_add_(0, edge_index[1], edge_weight)

    # replace self loops (if any) with diagonal values from D
    j = same.sum().item()
    if j>0:
        edge_index[0, same] = torch.arange(j)
        edge_index[1, same] = torch.arange(j)
        edge_weight[same] = -D[torch.arange(j)] # D and A have opposite sign when computing L
    # add diagonal values if they did not fit in the existing self-loops cells
    L_index = torch.cat([edge_index, torch.stack([torch.arange(j, num_nodes), torch.arange(j, num_nodes)])], 1)
    L_weight = torch.cat([-edge_weight, D[j:]], 0)
    # construct an unnormalized laplacian matrix L
    L = coo_matrix((L_weight, (L_index[0], L_index[1])), shape=(num_nodes, num_nodes))
    return L, D.numpy()

class SpectralEmbeddingUnnormalized(torch.nn.Module):
    """
    Spectral Embedding method generates node embeddings for the graph, using the
    unnormalized Laplacian matrix. Algorithm proposed by Belkin and Niyogi.
    """
    def __init__(self, dim:int=32):
        """
        Initializes Spectral Embedding method.
        
        :param dim: The number of dimensions that should be generated by the
        Spectral Embedding method.
        :type dim: int
        """
        self.dim = dim
        super().__init__()
    
    def forward(self, edge_index: torch.Tensor, edge_weight: torch.Tensor = None):
        """
        Forward method to generate Spectral Embedding based on provided edge indices
        and their corresponding weights.
        
        :param edge_index: Tensor of size (2, M) where M is a number of edges. Graph is
        assumed to be undirected, and it assumed to contain edges in both directions
        in 'edge_weight', except for self-loops.
        :type edge_index: torch.Tensor
        :param edge_weight: Vector of size M, defines a non-negative weight of the
        corresponding edge from 'edge_index'
        :type edge_weight: torch.Tensor
        """
        L, _ = _construct_unnormalized_laplacian(edge_index, edge_weight)
        # find eigenvectors
        init_eigenvectors = np.random.rand(L.shape[0], self.dim+1)
        init_eigenvectors[:, 0] = 1
        _, V = lobpcg(L, init_eigenvectors, largest=False, maxiter=10)
        return torch.tensor(V[:, 1:].copy())

class SpectralEmbeddingSideNorm(torch.nn.Module):
    """
    Spectral Embedding side-normalized method generates node embeddings for the graph,
    using the Laplacian matrix normalized from one side. Algorithm proposed by Shi and Malik.
    """
    def __init__(self, dim:int=32):
        """
        Initializes Spectral Embedding side-normalized method.
        
        :param dim: The number of dimensions that should be generated by the
        Spectral Embedding side-normalized method.
        :type dim: int
        """
        self.dim = dim
        super().__init__()
    
    def forward(self, edge_index: torch.Tensor, edge_weight: torch.Tensor = None):
        """
        Forward method to generate Spectral Embedding side-normalized based o
        the provided edge indices and their corresponding weights.
        
        :param edge_index: Tensor of size (2, M) where M is a number of edges. Graph is
        assumed to be undirected, and it assumed to contain edges in both directions
        in 'edge_weight', except for self-loops.
        :type edge_index: torch.Tensor
        :param edge_weight: Vector of size M, defines a non-negative weight of the
        corresponding edge from 'edge_index'
        :type edge_weight: torch.Tensor
        """
        L, D = _construct_unnormalized_laplacian(edge_index, edge_weight)
        # normalize weights by columns
        L.data /= D[L.col] + 1e-9
        # find eigenvectors
        init_eigenvectors = np.random.rand(L.shape[0], self.dim+1)
        init_eigenvectors[:, 0] = 1
        _, V = lobpcg(L, init_eigenvectors, largest=False, maxiter=10)
        return torch.tensor(V[:, 1:].copy())

class SpectralEmbeddingNorm(torch.nn.Module):
    """
    Spectral Embedding Normalized method generates node embeddings for the graph,
    using the Laplacian matrix normalized from both sides. Algorithm proposed by
    Ng, Jordan, and Weiss.
    """
    def __init__(self, dim:int=32):
        """
        Initializes Spectral Embedding Normalized method.
        
        :param dim: The number of dimensions that should be generated by the
        Spectral Embedding Normalized method.
        :type dim: int
        """
        self.dim = dim
        super().__init__()
    
    def forward(self, edge_index: torch.Tensor, edge_weight: torch.Tensor = None):
        """
        Forward method to generate Spectral Embedding Normalized based o
        the provided edge indices and their corresponding weights.
        
        :param edge_index: Tensor of size (2, M) where M is a number of edges. Graph is
        assumed to be undirected, and it assumed to contain edges in both directions
        in 'edge_weight', except for self-loops.
        :type edge_index: torch.Tensor
        :param edge_weight: Vector of size M, defines a non-negative weight of the
        corresponding edge from 'edge_index'
        :type edge_weight: torch.Tensor
        """
        L, D = _construct_unnormalized_laplacian(edge_index, edge_weight)
        # normalize weights by columns and rows
        L.data /= D[L.col] ** 0.5 + 1e-9
        L.data /= D[L.row] ** 0.5 + 1e-9
        # find eigenvectors
        init_eigenvectors = np.random.rand(L.shape[0], self.dim+1)
        init_eigenvectors[:, 0] = 1
        _, V = lobpcg(L, init_eigenvectors, largest=False, maxiter=10)
        V = torch.tensor(V[:, 1:].copy()) + 1e-9
        # normalize rows
        V = V / ((V**2).sum(1) ** 0.5).reshape(-1, 1)
        return V


class SpectralEmbedding(torch.nn.Module):
    """
    Spectral Embedding method generates node embeddings for the graph,
    using the selected Spectral Embedding algorithm.
    """
    def __init__(self, dim:int=32, mode:str="normalized"):
        """
        Initializes Spectral Embedding algorithm with the given dimensionality
        and selected algorithm.
        
        :param dim: The number of dimensions that should be generated by the
        Spectral Embedding method.
        :type dim: int
        :param mode: The name of the Spectral Embedding algorithm that should be used.
        Only three options are possible: "normalized", "side normalized", "unnormalized".
        "normalized" stands for SpectralEmbeddingNorm algorithm proposed by Ng, Jordan, and Weiss;
        "side normalized" stands for SpectralEmbeddingSideNorm algorithm proposed by Shi and Malik;
        "unnormalized" stands for SpectralEmbeddingUnnormalized algorithm proposed by Belkin and Niyogi.
        :type mode: str
        """
        super().__init__()
        if mode not in ["normalized", "side normalized", "unnormalized"]:
            raise Exception('"mode" must be one of the following strings: "normalized", "side normalized", "unnormalized"')
        self._underlying_method = None
        if mode=="normalized":
            self._underlying_method = SpectralEmbeddingNorm(dim)
        elif mode=="side normalized":
            self._underlying_method = SpectralEmbeddingSideNorm(dim)
        elif mode=="unnormalized":
            self._underlying_method = SpectralEmbeddingUnnormalized(dim)
    
    def forward(self, edge_index: torch.Tensor, edge_weight: torch.Tensor = None):
        """
        Forward method to generate Spectral Embeddings using the chosen method
        based on the provided edge indices and their corresponding weights.
        
        :param edge_index: Tensor of size (2, M) where M is a number of edges. Graph is
        assumed to be undirected, and it assumed to contain edges in both directions
        in 'edge_weight', except for self-loops.
        :type edge_index: torch.Tensor
        :param edge_weight: Vector of size M, defines a non-negative weight of the
        corresponding edge from 'edge_index'
        :type edge_weight: torch.Tensor
        """
        return self._underlying_method.forward(edge_index, edge_weight)